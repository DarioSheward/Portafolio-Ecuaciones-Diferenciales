\documentclass[../portafolio.tex]{subfiles}

\begin{document}

\chapter{Ecuación integral}
\label{g3_ej12}
\hfill \textbf{Fecha de la actividad:} 18 de noviembre de 2024

\medskip

En esta ocasión se revisa una ecuación integral, con una función a encontrar, a través de la discretización de los intervalos y el uso de la regla trapezoidal compuesta. Gracias al álgebra lineal y a Python podremos obtener estimaciones numéricas tanto cercanas como terriblemente lejanas a la solución exacta.

\section*{Objetivos}
\begin{itemize}
\item Resolver una ecuación integral para encontrar una función, numéricamente, usando la regla trapezoidal.
\end{itemize}

Se nos entrega la siguiente ecuación integral \eqref{g3_ej12:eq}.

\begin{equation} \label{g3_ej12:eq}
\int_0^1 \left(s^2+t^2\right)^{\frac{1}{2}}u(t)\quad dt = \frac{1}{3}[\left(s^2+1)\right)^{\frac{3}{2}} - s^3]
\end{equation}
Se solicita encontrar $u(t)$ como función de $t$, determinando intervalos discretos para $0 \leq t \leq 1$ y $0 \leq s \leq 1$ en $N$ subintervalos cada uno.

Para resolver el problema deberemos considerar un valor de $s$ a la vez, y quedando un sistema de ecuaciones con cada ecuación cuna distinta $s$, evaluando $t$ en el intervalo de la integral. Sea ese entonces nuestro próximo sistema de ecuaciones.

Primero, revisemos la solución numérica de la integral.

\section{Regla del trapecio}
La regla del trapecio ofrece una estimación numérica de una integral donde una la recta que une dos puntos para formar un trapecio cuya área se sumará al resto de la región, definida en términos generales como \eqref{g3_ej12:trapecio} \citep{navarro2024int}.

\begin{equation}\label{g3_ej12:trapecio}
\int_a^b f(x) \, dx \approx \frac{h}{2} \left[ f(a) + 2 \sum_{i=1}^{n-1} f(a + ih) + f(b) \right]
\end{equation}

Al aplicarla a la integral de \eqref{g3_ej12:eq}. Sean $t_0=0$ y $t_N=1$

\begin{equation}\label{g3_ej12:aplic}
\int_0^1 \left(s^2+t^2\right)^{\frac{1}{2}}u(t)\quad dt \approx \frac{1}{2N} \left[ s u(t_0) + 2 \sum_{i=1}^{n-1} \left(s^2+t^2\right)^{\frac{1}{2}}u(t_i) + \left(s^2 +1\right)^{\frac{1}{2}}u(t_N) \right]
\end{equation}

Al existir $N+1$ valores de $s$, podemos escribir esta ecuación como un sistema.
\begin{equation}
\int_0^1 \left(s^2+t^2\right)^{\frac{1}{2}}u(t)\quad dt \approx \frac{1}{2N} \left[ s_0 u(t_0) + 2 \sum_{i=1}^{n-1} \left(s_j^2+t_i^2\right)^{\frac{1}{2}}u(t_i) + \left(s_{N}^2 +1\right)^{\frac{1}{2}}u(t_N) \right]
\end{equation}

\begin{equation}\label{g3_ej12:sistema}
\frac{1}{2N} \left[ s_0 u(t_0) + 2 \sum_{i=1}^{n-1} \left(s_j^2+t_i^2\right)^{\frac{1}{2}}u(t_i) + \left(s_{N}^2 +1\right)^{\frac{1}{2}}u(t_N) \right] = \frac{1}{3}[\left(s_j^2+1)\right)^{\frac{3}{2}} - s_j^3]
\end{equation}

Para simplificar la expresión se agregarán pesos que dependen del intervalo $1/N$ por lo que también depende de $i$. Para $i=0 \vee i=N$, $w_i=1/2$. Mientras que para  $i\neq 0 \wedge i\neq N$, $w_i=1$
\begin{equation}
w_i \left(s_j^2+t_i^2\right)^{\frac{1}{2}}u_i(t_i) = \frac{1}{3}[\left(s_j^2+1)\right)^{\frac{3}{2}} - s_j^3]
\end{equation}

Consideremos $F_{ji}(s_j,t_i)=w_i \left(s_j^2+t_i^2\right)^{\frac{1}{2}}$ y $B_j(s_j)=\frac{1}{3}[\left(s_j^2+1)\right)^{\frac{3}{2}} - s_j^3]$, entonces queda reducido a
\begin{equation}
F_{ji}(s_j,t_i)\cdot U_i(t_i)=B_j(s_j).
\end{equation}
\section{Solución del sistema de ecuaciones}
Con el fin de poder entregar este portafolio a tiempo, se realizarán estimaciones numéricas con valores de $3\leq N \leq 15$. Para facilitar la vida del programador, se utiliza la función \texttt{np.linalg.solve(A,b)} \citep{numpy}. En este caso \texttt{A}$=F_{ji}(s_j,t_i)$ y \texttt{b}$=B_j(s_j)$.

Aparte, el ejercicio nos informa que la solución exacta es $u(t)=t$, por lo que podremos comparar y definir los errores de las estimaciones.

\begin{minted}{python}
for N in Ns: 	# El ciclo principal depende del los valores de N.
    h = 1 / N	# Se establece el tamaño de los intervalos.
    t = np.linspace(0, 1, N+1) 	# Se preparan los arreglos de las variables s y t.
    s = np.linspace(0, 1, N+1) 
    
    b=np.empty(N+1)	# Se establecen las matrices con las que se operaran.
    A = np.zeros((N+1, N+1))
    
    for i in range(N+1):	# Se realiza un ciclo para rellenar los arreglo A, w y b. a partir de los distintos valores de s y t.
        
        for j in range(N+1):
            if 1 <= j <= N-1:
                w_j = 1
            else:
                w_j=0.5 
            estaT= (h) * w_j * np.sqrt(s[i]**2 + t[j]**2)
            A[i, j] = estaT

        
        b[i] = (1/3)*((s[i]**2 + 1)**(3/2) - s[i]**(3))
    u_numerico = np.linalg.solve(A, b)	#Se resuelve el sistema de ecuaciones de tamaño (N+1)X(N+1).
    u = t 	#Se define la solución exacta para definir errores.
    error =(np.abs(u_numerico- u))
    plt.subplot(211)		#Se grafica.
    plt.plot(t,u_numerico,linestyle='--',label=f'N={N}', marker='.')
    plt.subplot(212)
    plt.plot(t,error,'.-',label=f'N={N}')
\end{minted}

Entonces resulta en la gráfica \ref{g3_ej12:graf}

\begin{figure}
\centering
\includegraphics[scale=0.6]{../img/sistema_0.png}
\caption{Estimaciones numéricas con distintos intervalos.}\label{g3_ej12:graf}
\end{figure}

\section{Análisis de resultados}
Por extraño que parezca el gráfico, presenta mucha información general de como conviene resolver este tipo de problemas. El generar muchos intervalos más pequeños produjo desviaciones que debieron ser compensadas más adelante y que pudieron generar mayor inestabilidad aún. En general, las estimaciones se benefician de pocos intervalos, seguramente por el bajo costo computacional y la necesidad de una precisión numérica dentro de las capacidades de las arquitecturas modernas. Sin embargo, otro factor que parece importante es como las estimaciones presentan bajos errores para valores de $t$ menores a $0.1$. Podemos suponer que se debe a como los puntos definen los intervalos. Consideremos que la primera estimación siempre será cero, la siguiente, podríamos esperar que el error no esté directamente relacionado con el anterior, al tratarse de un sistema de ecuaciones. 
\begin{figure}
\centering
\includegraphics[scale=0.75]{../img/sistema_1.png}
\caption{Estimaciones numéricas para $3\leq N \leq 5$}\label{g3_ej12:graf1}
\end{figure}
De la figura \ref{g3_ej12:graf1}, hemos de notar como el error cometido en cada estimación esta relacionado fuertemente con  el problema tratado y no solo en la cantidad de intervalos\footnote{Este fenómeno es similar al ocurrido con las interpolaciones, al resultarnos imágenes de la función a determinar sumamente inestables, tal como tienden a oscilar las interpolaciones de Lagrange.}.
\section*{Conclusiones}
La solución de este ejercicio no es sencilla, requiere de firme manejo de álgebra lineal y de reglas de integración numérica. En general, con esto basta para diseñar la solución. Luego, se utilizó Python para realizar la estimación numérica de la solución, con distintas cantidades de subintervalos. Resultando en una gráfica extraña pero informativa sobre las capacidades numéricas de la solución. Ante estos resultados se considera que los objetivos fueron logrados.
\subsection*{Agradecimientos}

Mil gracias a Valentina Santelices por la revisión.
\end{document}
